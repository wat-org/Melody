package com.wat.cloud.libvirt;

import java.io.IOException;
import java.util.Arrays;

import javax.xml.xpath.XPathExpressionException;

import org.libvirt.Connect;
import org.libvirt.Domain;
import org.libvirt.LibvirtException;
import org.libvirt.NetworkFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import com.wat.cloud.libvirt.exception.ProtectedAreaNotFoundException;
import com.wat.cloud.libvirt.exception.ProtectedAreaStillInUseException;
import com.wat.melody.cloud.instance.InstanceState;
import com.wat.melody.cloud.network.NetworkDevice;
import com.wat.melody.cloud.network.NetworkDeviceList;
import com.wat.melody.cloud.network.exception.IllegalNetworkDeviceListException;
import com.wat.melody.cloud.protectedarea.ProtectedAreaId;
import com.wat.melody.cloud.protectedarea.ProtectedAreaIds;
import com.wat.melody.cloud.protectedarea.ProtectedAreaName;
import com.wat.melody.cloud.protectedarea.exception.IllegalProtectedAreaIdException;
import com.wat.melody.cloud.protectedarea.exception.IllegalProtectedAreaNameException;
import com.wat.melody.common.ex.MelodyException;
import com.wat.melody.common.firewall.NetworkDeviceName;
import com.wat.melody.common.firewall.exception.IllegalNetworkDeviceNameException;
import com.wat.melody.common.properties.Property;
import com.wat.melody.common.properties.PropertySet;
import com.wat.melody.common.properties.exception.IllegalPropertyException;
import com.wat.melody.common.xml.Doc;
import com.wat.melody.common.xpath.XPathExpander;
import com.wat.melody.common.xpath.exception.XPathExpressionSyntaxException;

/**
 * <p>
 * Quick and dirty class which provides libvirt network management features.
 * </p>
 * 
 * @author Guillaume Cornet
 * 
 */
public abstract class LibVirtCloudNetwork {

	private static Logger log = LoggerFactory
			.getLogger(LibVirtCloudNetwork.class);

	private static NetworkDeviceName createNetworkDeviceName(String n) {
		try {
			return NetworkDeviceName.parseString(n);
		} catch (IllegalNetworkDeviceNameException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	public static final String LIBVIRT_CLOUD_NET_CONF = "/Cloud/libvirt/conf-net.xml";
	protected static Doc netconf = loadLibVirtCloudNetworkConfiguration();

	private static Doc loadLibVirtCloudNetworkConfiguration() {
		Doc doc = new Doc();
		try {
			doc.load(LIBVIRT_CLOUD_NET_CONF);
		} catch (MelodyException | IOException Ex) {
			throw new RuntimeException(
					"Failed to load LibVirtCloud Network Configuration File '"
							+ LIBVIRT_CLOUD_NET_CONF + "'.", Ex);
		}
		return doc;
	}

	protected static NetworkDeviceName eth0 = createNetworkDeviceName("eth0");

	/**
	 * When an instance is created, it is automatically associated a network
	 * device eth0 (LibVirt does this for you). In order to protect this network
	 * device, we can rely on Instance's Protected Areas. But we consider that
	 * Instance's Protected Areas are limited because there's no way to
	 * allow/deny network data to send/receive by this network device (you can
	 * change the Protected Area's rules, which will impact all the other
	 * instances of the Protected Area)... For these reason, we will
	 * automatically create a Protected Area and associate it to the network
	 * device. Such Protected Area is call a Self Protected Area. Via the Self
	 * Protected Area, we can allow/deny network data to send/receive by this
	 * network device without impact on other instance.
	 * 
	 * The Self Protected Area is created during the instance creation. Its
	 * Identifier can be found in the first filter-ref of the network filter of
	 * the network device.
	 */

	/**
	 * Self Protected Area are automatically created during network
	 * interface/instance creation. Such creation is fully automated. This
	 * method allow to generate a description, which will be used during the
	 * Self Protected Area creation.
	 */
	private static String generateSelfProtectedAreaDescription() {
		return "Protected area dedicated to an instance, generated by Melody.";
	}

	/**
	 * Self Protected Area are automatically created during network
	 * interface/instance creation. Such creation is fully automated. This
	 * method allow to generate a name, based on the given network device name,
	 * which will be used during the Self Protected Area creation.
	 */
	private static ProtectedAreaName generateSelfProtectedAreaName(
			String sInstanceId, NetworkDeviceName devname) {
		if (devname == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid "
					+ NetworkDeviceName.class.getCanonicalName() + ".");
		}
		// This formula should produce a unique name
		String name = "melody-self-protected-area:" + sInstanceId + ":"
				+ devname;
		try {
			return ProtectedAreaName.parseString(name);
		} catch (IllegalProtectedAreaNameException Ex) {
			throw new RuntimeException("Fail to convert '" + name + "' into '"
					+ ProtectedAreaName.class.getCanonicalName() + "'. "
					+ "If this error happened, you should modify the "
					+ "conversion rule.", Ex);
		}
	}

	/**
	 * <p>
	 * Create an empty self Protected Area, dedicated for the given domain, and
	 * the given network interface.
	 * </p>
	 * 
	 * @param ec2
	 * @param sInstanceId
	 *            is the name of the related domain.
	 * @param devname
	 *            is the name of the related network interface.
	 * 
	 * @return the newly created Protected Area Identifier.
	 * 
	 * @throws IllegalArgumentException
	 *             if cnx is <tt>null</tt>.
	 * @throws IllegalArgumentException
	 *             if the given network device name is <tt>null</tt>.
	 */
	private static ProtectedAreaId createSelfProtectedArea(Connect cnx,
			String sInstanceId, NetworkDeviceName devname) {
		log.trace("Creating Self Proptected Area for Network Device '"
				+ devname + "' of Domain '" + sInstanceId + "' ...");
		ProtectedAreaName name = generateSelfProtectedAreaName(sInstanceId,
				devname);
		String desc = generateSelfProtectedAreaDescription();
		ProtectedAreaId paId = LibVirtCloudProtectedArea.createProtectedArea(
				cnx, name, desc);
		log.debug("Self Proptected Area '" + paId
				+ "' created for Network Device '" + devname + "' of Domain '"
				+ sInstanceId + "'.");
		return paId;
	}

	private static void deleteSelfProtectedArea(Connect cnx,
			String sInstanceId, NetworkDeviceName devname,
			ProtectedAreaId selfProtectedAreaId) {
		try {
			log.trace("Deleting Self Proptected Area '" + selfProtectedAreaId
					+ "' for Network Device '" + devname + "' of Domain '"
					+ sInstanceId + "' ...");
			LibVirtCloudProtectedArea.destroyProtectedArea(cnx,
					selfProtectedAreaId);
			log.debug("Self Proptected Area '" + selfProtectedAreaId
					+ "' deleted for Network Device '" + devname
					+ "' of Domain '" + sInstanceId + "'.");
		} catch (ProtectedAreaStillInUseException Ex) {
			throw new RuntimeException("unexcepted error while deleting self "
					+ "protected area '" + selfProtectedAreaId
					+ "'. Can't be in use.", Ex);
		}
	}

	/**
	 * @param d
	 *            is a {@link Domain}.
	 * 
	 * @return a {@link NetworkDeviceList}, which contains the
	 *         {@link NetworkDevice}s of the given {@link Domain}.
	 * 
	 * @throws IllegalArgumentException
	 *             if the given {@link Domain} is <tt>null</tt>.
	 */
	public static NetworkDeviceList getNetworkDevices(Domain d) {
		if (d == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid " + Domain.class.getCanonicalName()
					+ ".");
		}
		try {
			NetworkDeviceList ndl = new NetworkDeviceList();
			Doc doc = LibVirtCloud.getDomainXMLDesc(d);
			NodeList nl = doc.evaluateAsNodeList("/domain/devices/interface"
					+ "[@type='network']/filterref/@filter");
			for (int i = 0; i < nl.getLength(); i++) {
				String filter = nl.item(i).getNodeValue();
				NetworkDeviceName devname = getNetworkDeviceNameFromMasterNetworkFilter(filter);
				String mac = getDomainMacAddress(d, devname);
				String ip = getDomainIpAddress(mac);
				String fqdn = getDomainDnsName(mac);
				ndl.addNetworkDevice(new NetworkDevice(devname, mac, ip, fqdn,
						null, null, null, null));
			}
			if (ndl.size() == 0) {
				throw new RuntimeException("Failed to build Domain '"
						+ d.getName() + "' Network Device List. "
						+ "No Network Device found. "
						+ "There should be at least one network device called "
						+ "'eth0'.");
			}
			return ndl;
		} catch (XPathExpressionException | LibvirtException
				| IllegalNetworkDeviceListException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	private static final String DETACH_NETWORK_DEVICE_XML_SNIPPET = "<interface type='network'>"
			+ "<mac address='ยง[vmMacAddr]ยง'/>"
			+ "<source network='default'/>"
			+ "</interface>";

	public static void detachNetworkDevice(Domain d, NetworkDevice netdev) {
		if (netdev == null) {
			return;
		}
		if (d == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid " + Domain.class.getCanonicalName()
					+ ".");
		}

		try {
			NetworkDeviceName devname = netdev.getNetworkDeviceName();
			String sInstanceId = d.getName();

			// Search network device @mac
			String mac = getDomainMacAddress(d, devname);
			PropertySet vars = new PropertySet();
			vars.put(new Property("vmMacAddr", mac));

			// Detach the network device
			log.trace("Detaching Network Device '" + devname + "' on Domain '"
					+ sInstanceId + "' ...");
			int flag = LibVirtCloud.getDomainState(d) == InstanceState.RUNNING ? 3
					: 2;
			d.detachDeviceFlags(XPathExpander.expand(
					DETACH_NETWORK_DEVICE_XML_SNIPPET, null, vars), flag);
			log.debug("Network Device '" + devname + "' detached on Domain '"
					+ sInstanceId + "'.");

			// Destroy the network filter
			deleteMasterNetworkFilter(d, devname);

			// Release the @mac
			unregisterMacAddress(mac);
		} catch (XPathExpressionSyntaxException | IllegalPropertyException
				| LibvirtException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	private static final String ATTACH_NETWORK_DEVICE_XML_SNIPPET = "<interface type='network'>"
			+ "<mac address='ยง[vmMacAddr]ยง'/>"
			+ "<model type='virtio'/>"
			+ "<source network='default'/>"
			+ "<filterref filter='ยง[vmName]ยง-ยง[eth]ยง-nwfilter'/>"
			+ "</interface>";

	public static void attachNetworkDevice(Domain d, NetworkDevice netdev) {
		if (netdev == null) {
			return;
		}
		if (d == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid " + Domain.class.getCanonicalName()
					+ ".");
		}

		try {
			String sInstanceId = d.getName();
			String sMacAddr = generateUniqMacAddress();
			NetworkDeviceName devname = netdev.getNetworkDeviceName();

			// Create a master network filter for the network device
			PropertySet vars = new PropertySet();
			vars.put(new Property("vmMacAddr", sMacAddr));
			vars.put(new Property("vmName", sInstanceId));
			vars.put(new Property("eth", devname.getValue()));

			// associate the network device the same protected area
			ProtectedAreaIds paids = LibVirtCloudProtectedArea
					.getProtectedAreas(sInstanceId);
			try {
				createMasterNetworkFilter(d.getConnect(), sInstanceId, devname,
						sMacAddr, paids);
			} catch (ProtectedAreaNotFoundException Ex) {
				unregisterMacAddress(sMacAddr);
				throw new RuntimeException("Since this protected area id have "
						+ "been retrieve from the domain, this protected area "
						+ "must exists.", Ex);
			}
			// Attach the network device
			log.trace("Attaching Network Device '" + devname + "' on Domain '"
					+ sInstanceId + "' ... MacAddress is '" + sMacAddr + "'.");
			int flag = LibVirtCloud.getDomainState(d) == InstanceState.RUNNING ? 3
					: 2;
			d.attachDeviceFlags(XPathExpander.expand(
					ATTACH_NETWORK_DEVICE_XML_SNIPPET, null, vars), flag);
			log.debug("Network Device '" + devname + "' attached on Domain '"
					+ sInstanceId + "'.");
		} catch (XPathExpressionSyntaxException | IllegalPropertyException
				| LibvirtException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	public static String getDomainMacAddress(Domain d, NetworkDeviceName devname) {
		if (devname == null) {
			devname = eth0;
		}
		try {
			Doc doc = LibVirtCloud.getDomainXMLDesc(d);
			return doc.evaluateAsString("/domain/devices/interface"
					+ "[@type='network' and filterref/@filter='"
					+ getMasterNetworkFilter(d, devname) + "']/mac/@address");
		} catch (XPathExpressionException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	public static String getDomainIpAddress(String sMacAddr) {
		if (sMacAddr == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid " + String.class.getCanonicalName()
					+ ".");
		}
		try {
			return netconf.evaluateAsString("/network/ip/dhcp"
					+ "/host[ upper-case(@mac)=upper-case('" + sMacAddr
					+ "') ]/@ip");
		} catch (XPathExpressionException Ex) {
			throw new RuntimeException("Hard coded xpath expression is not "
					+ "valid. Check the source code.");
		}
	}

	public static String getDomainDnsName(String sMacAddr) {
		if (sMacAddr == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid " + String.class.getCanonicalName()
					+ ".");
		}
		try {
			return netconf.evaluateAsString("/network/ip/dhcp"
					+ "/host[ upper-case(@mac)=upper-case('" + sMacAddr
					+ "') ]/@name");
		} catch (XPathExpressionException Ex) {
			throw new RuntimeException("Hard coded xpath expression is not "
					+ "valid. Check the source code.");
		}
	}

	protected static synchronized String generateUniqMacAddress() {
		Element hostNode = null;
		try {
			hostNode = (Element) netconf.evaluateAsNode("/network/ip/dhcp/host"
					+ "[ not(exists(@allocated))"
					+ " or @allocated!='true' ][1]");
		} catch (XPathExpressionException Ex) {
			throw new RuntimeException(Ex);
		}
		if (hostNode == null) {
			throw new RuntimeException("No more free Mac Address.");
		}
		if (!hostNode.hasAttribute("mac")) {
			throw new RuntimeException("No attribute 'mac' defined.");
		}
		String sFirstFreeMacAddr = hostNode.getAttribute("mac");
		log.trace("Allocating Mac Address '" + sFirstFreeMacAddr + "' ...");
		hostNode.setAttribute("allocated", "true");
		netconf.store();
		log.debug("Mac Address '" + sFirstFreeMacAddr + "' allocated.");
		return sFirstFreeMacAddr;
	}

	protected static synchronized void unregisterMacAddress(String sMacAddr) {
		if (sMacAddr == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid " + String.class.getCanonicalName()
					+ ".");
		}
		log.trace("Releasing Mac Address '" + sMacAddr + "' ...");
		Element nMacAddr = null;
		try {
			nMacAddr = (Element) netconf.evaluateAsNode("/network/ip/dhcp/host"
					+ "[ upper-case(@mac)=upper-case('" + sMacAddr
					+ "') and exists(@allocated) ]");
		} catch (XPathExpressionException Ex) {
			throw new RuntimeException(Ex);
		}
		if (nMacAddr == null) {
			return;
		}
		nMacAddr.removeAttribute("allocated");
		netconf.store();
		log.debug("Mac Address '" + sMacAddr + "' released.");
	}

	private static boolean networkFilterExists(Connect cnx, String nwfilterid)
			throws LibvirtException {
		if (nwfilterid == null) {
			return false;
		}
		String[] names = cnx.listNetworkFilters();
		return Arrays.asList(names).contains(nwfilterid);
	}

	/*
	 * A dedicated Network Filter is associated to each network device of each
	 * Domain. The Network filter name is
	 * '<instance-id>-<device-name>-nwfilter'.
	 * 
	 * This Network Filter is the placeholder of 'common' firewall rules (e.g.
	 * which apply to all network device).
	 * 
	 * The first element of the Master Network Filter must be a filterref, which
	 * points to the Self Network Filter of the network device.
	 * 
	 * A Self Network Filter is the placeholder of firewall rules which are
	 * specific to the network device.
	 */
	private static String getMasterNetworkFilter(Domain d,
			NetworkDeviceName devname) {
		if (d == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid " + Domain.class.getCanonicalName()
					+ ".");
		}
		if (devname == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid "
					+ NetworkDeviceName.class.getCanonicalName() + ".");
		}
		try {
			return d.getName() + "-" + devname.getValue() + "-nwfilter";
		} catch (LibvirtException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	private static NetworkDeviceName getNetworkDeviceNameFromMasterNetworkFilter(
			String filter) {
		filter = filter.substring(0, filter.lastIndexOf('-'));
		filter = filter.substring(filter.lastIndexOf('-') + 1);
		try {
			return NetworkDeviceName.parseString(filter);
		} catch (IllegalNetworkDeviceNameException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	/*
	 * synchronized because this will modify many network filters.
	 */
	protected static synchronized void createMasterNetworkFilter(Connect cnx,
			String sInstanceId, NetworkDeviceName devname, String sMacAddr,
			ProtectedAreaIds protectedAreaIds)
			throws ProtectedAreaNotFoundException {
		if (cnx == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid " + Connect.class.getCanonicalName()
					+ ".");
		}
		if (protectedAreaIds == null) {
			protectedAreaIds = new ProtectedAreaIds();
		}
		try {
			log.trace("Creating Master Network Filter '" + sInstanceId + "-"
					+ devname + "-nwfilter' for Network Device '" + devname
					+ "' of Domain '" + sInstanceId + "' ...");
			// Create the Self Protected Area, for the first network device
			ProtectedAreaId selfProtectedAreaId = createSelfProtectedArea(cnx,
					sInstanceId, devname);
			// register the domain in each protected area
			ProtectedAreaIds paIds = new ProtectedAreaIds();
			paIds.add(selfProtectedAreaId);
			paIds.addAll(protectedAreaIds);
			try {
				LibVirtCloudProtectedArea.associateProtectedAreas(cnx,
						sInstanceId, devname, sMacAddr, paIds);
			} catch (ProtectedAreaNotFoundException Ex) {
				log.error("Fail to associate Protected Areas " + paIds
						+ " on Network Device '" + devname + "' of Domain '"
						+ sInstanceId
						+ "'. Rolling-back Self Protected Area creation...");
				deleteSelfProtectedArea(cnx, sInstanceId, devname,
						selfProtectedAreaId);
				log.debug("Self Protected Area " + selfProtectedAreaId
						+ " creation rolled-back on Network Device '" + devname
						+ "' of Domain '" + sInstanceId + "'.");
				throw Ex;
			}

			// build the master network filter
			String DOMAIN_NETWORK_FILTER_XML_SNIPPET = "<filter name='"
					+ sInstanceId + "-" + devname + "-nwfilter' chain='root'>";
			// declare the self protected area
			DOMAIN_NETWORK_FILTER_XML_SNIPPET += "<filterref filter='"
					+ selfProtectedAreaId + "'/>";
			// declare all other protected area
			for (ProtectedAreaId paId : protectedAreaIds) {
				DOMAIN_NETWORK_FILTER_XML_SNIPPET += "<filterref filter='"
						+ paId + "'/>";
			}
			// clean-traffic will drop packets sent on eth1 and reply on eth0
			// + "<filterref filter='clean-traffic'/>"
			// accept all outgoing traffic and reject all incoming traffic
			DOMAIN_NETWORK_FILTER_XML_SNIPPET += "<rule action='accept' direction='out' priority='500'>"
					+ " <all state='NEW'/>"
					+ "</rule>"
					+ "<rule action='accept' direction='out' priority='500'>"
					+ "  <all state='ESTABLISHED,RELATED'/>"
					+ "</rule>"
					+ "<rule action='accept' direction='in' priority='500'>"
					+ "  <all state='ESTABLISHED'/>"
					+ "</rule>"
					+ "<rule action='accept' direction='in' priority='500'>"
					+ "  <igmp/>"
					+ "</rule>"
					+ "<rule action='reject' direction='inout' priority='500'>"
					+ "  <all/>" + "</rule>";
			DOMAIN_NETWORK_FILTER_XML_SNIPPET += "</filter>";

			cnx.networkFilterDefineXML(DOMAIN_NETWORK_FILTER_XML_SNIPPET);
			log.debug("Master Network Filter '" + sInstanceId + "-" + devname
					+ "-nwfilter' created for Network Device '" + devname
					+ "' of Domain '" + sInstanceId + "'.");
		} catch (LibvirtException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	protected static synchronized void deleteMasterNetworkFilter(Domain d,
			NetworkDeviceName devname) {
		if (d == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid " + Domain.class.getCanonicalName()
					+ ".");
		}
		try {
			Connect cnx = d.getConnect();
			String sInstanceId = d.getName();
			ProtectedAreaId selfProtectedAreaId = getSelftProtectedAreaId(d,
					devname);
			// delete Master Network Filter
			String filter = getMasterNetworkFilter(d, devname);
			log.trace("Deleting Master Network Filter '" + filter
					+ "' for Network Device '" + devname + "' of Domain '"
					+ sInstanceId + "' ...");
			NetworkFilter nf = cnx.networkFilterLookupByName(filter);
			nf.undefine();
			// un-register the domain in each protected area
			LibVirtCloudProtectedArea.deassociateProtectedAreas(cnx,
					sInstanceId, devname);
			// delete Self Protected Area
			deleteSelfProtectedArea(cnx, sInstanceId, devname,
					selfProtectedAreaId);
			log.debug("Master Network Filter '" + filter
					+ "' deleted for Network Device '" + devname
					+ "' of Domain '" + sInstanceId + "'.");
		} catch (LibvirtException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	protected static ProtectedAreaId getSelftProtectedAreaId(Domain d,
			NetworkDeviceName devname) {
		if (d == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid " + Domain.class.getCanonicalName()
					+ ".");
		}
		if (devname == null) {
			throw new IllegalArgumentException("null: Not accepted. "
					+ "Must be a valid "
					+ NetworkDeviceName.class.getCanonicalName() + ".");
		}
		try {
			String filter = getMasterNetworkFilter(d, devname);
			if (!networkFilterExists(d.getConnect(), filter)) {
				return null;
			}
			NetworkFilter nf = d.getConnect().networkFilterLookupByName(filter);
			Doc doc = new Doc();
			doc.loadFromXML(nf.getXMLDesc());
			String v = doc.evaluateAsString("//filterref[1]/@filter");
			if (v == null) {
				throw new RuntimeException("The instance '" + d.getName()
						+ "' has a first filterref which contains a null "
						+ "value. "
						+ "Because this filterref have been automatically "
						+ "created during this instance creation, such error "
						+ "couldn't happened. "
						+ "The source code have changed and a bug have been "
						+ "introduced.");
			}
			try {
				return ProtectedAreaId.parseString(v);
			} catch (IllegalProtectedAreaIdException Ex) {
				throw new RuntimeException("The instance '" + d.getName()
						+ "' has a first filterref which contains an illegal "
						+ "value '" + v + "'. "
						+ "Because this filterref have been automatically "
						+ "created during this instance creation, such error "
						+ "couldn't happened. "
						+ "The source code have changed and a bug have been "
						+ "introduced.");
			}

		} catch (MelodyException | XPathExpressionException | LibvirtException
				| IOException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	/**
	 * Create an empty network filter
	 */
	protected static String createNetworkFilter(Connect cnx, String nwfid) {
		try {
			if (networkFilterExists(cnx, nwfid)) {
				throw new RuntimeException(nwfid + ": network filter "
						+ "already exists.");
			}
			String NETWORK_FILTER_XML_SNIPPET = "<filter name='" + nwfid
					+ "' chain='root'>" + "</filter>";
			cnx.networkFilterDefineXML(NETWORK_FILTER_XML_SNIPPET);
			return nwfid;
		} catch (LibvirtException Ex) {
			throw new RuntimeException(Ex);
		}
	}

	protected static void deleteNetworkFilter(Connect cnx, String nwfid) {
		try {
			if (!networkFilterExists(cnx, nwfid)) {
				return;
			}
			NetworkFilter nf = cnx.networkFilterLookupByName(nwfid);
			nf.undefine();
		} catch (LibvirtException Ex) {
			throw new RuntimeException(Ex);
		}
	}

}